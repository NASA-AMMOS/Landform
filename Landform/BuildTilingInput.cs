using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading;
using System.Text.RegularExpressions;
using CommandLine;
using Microsoft.Xna.Framework;
using JPLOPS.MathExtensions;
using JPLOPS.Geometry;
using JPLOPS.Imaging;
using JPLOPS.Pipeline;
using JPLOPS.Pipeline.AlignmentServer;
using JPLOPS.Pipeline.TilingServer;
using JPLOPS.Util;

/// <summary>
/// Creates leaf, and sometimes also parent, tile meshes and textures for a Landform alignment project.
///
/// This stage typically runs before build-tileset in a Landform contextual or tactical tileset workflow, possibly with
/// blend-images intervening.
///
/// Leaf tile meshes are always created by applying a tiling scheme to subdivide the (finest LOD) scene mesh.  Leaf tile
/// textures are backprojected from observation images in contextual mesh workflows, and (typically) clipped from the
/// source image in tactical tiling workflows.
///
/// As long as texturing is enabled, UVs are always assigned to tile meshes.  Depending on the workflow they may
///
/// (a) be clipped from the source mesh, if it had UVs
/// (b) be assigned by UVAtlas or HeightmapAtlas
/// (c) be assigned by texture projection.
///
/// Case (c) is rare, it can only happen in general if all of the following hold:
///
/// (1) --intputmesh and --input texture are specified
/// (2) the input mesh (or some LOD of it, possibly including "fixup" LOD internally generated by Landform) does not
///     already have UVs
/// (3) the mesh frame is "local_level", "sitedrive", "site", "rover", or "observation" (or "tactical" where the mission
///     tactical mesh frame is one of those)
/// (4) the input mesh and texture filenames are matching rover product IDs (possibly different variants/versions)
/// (5) PDS headers for the input texture are available for its camera model and transform to mesh frame
///
/// For M2020 Condition (1) only holds for the tactical mesh tiling workflow, not contextual.  So texture projection is
/// never enabled for M2020 contextual meshes. All but the condition (2) should generally hold for tactical mesh tiling.
/// Condition (2) is essentially rare, because IV/OBJ tactical meshes are always generated with UVs.  However, in the
/// event that our LOD fixup algorithm generates its own LODs, including the case that we loaded a single giant IV/OBJ
/// with no precomputed LODs (which has occurred in some variations of the upstream mesh generation flow), texture
/// projection becomes important, because it allows us to assign UVs that work with the original unomodified tactical
/// image.
///
/// For tactical tiling workflows where the input mesh RDR has existing LODs (or Landform created them with its LOD
/// fixup logic), build-tiling-input will also typically define all parent tile meshes from the coarser LODs of the
/// input mesh.
///
/// The tile meshes and textures are saved to project storage, along with a TileList data product which indexes them
/// and contains some related metadata.  The TileList is referred to by the SceneMesh in the alignment project database
///
/// See build-tileset for more details.
///
/// Example:
///
/// Landform.exe build-tiling-input windjana
///
/// </summary>
namespace JPLOPS.Landform
{
    [Verb("build-tiling-input", HelpText = "builds textured tiles from a full scene mesh")]
    [EnvVar("TILING")]
    public class BuildTilingInputOptions : TilingCommandOptions
    {
        [Value(0, Required = false, HelpText = "project name, defaults to input mesh basename if --inputmesh and --input texture are specified", Default = null)]
        public override string ProjectName { get; set; }

        [Option(Default = "None", HelpText = "Mission to use if creating project (only if --inputmesh and --inputtexture (or texturing disabled), optional :venue override, e.g. None, MSL, M2020, M20SOPS, M20SOPS:dev, M20SOPS:sbeta")]
        public string Mission { get; set; }

        [Option(HelpText = "Scene mesh coordinate frame: auto, tactical, passthrough", Default = "auto")]
        public string MeshFrame { get; set; }

        [Option(Default = null, HelpText = "Scene mesh texture image to bake into tiles, backproject observations instead if omitted")]
        public string InputTexture { get; set; }

        [Option(Default = false, HelpText = "Don't replace existing tile mesh texture coordinates with UVAtlas or texture projection")]
        public bool NoRedoTileMeshUVs { get; set; }

        [Option(HelpText = "Don't respect --maxtexelspermeter when splitting tiles if more texture resolution is available from source images", Default = !TilingDefaults.TEXTURE_SPLIT_RESPECT_MAX_TEXELS_PER_METER)]
        public bool NoTextureSplitRespectMaxTexelsPerMeter { get; set; }

        [Option(HelpText = "Percentage of pixels to test when deciding to split a tile based on resolution (speed vs quality), 0 disables texture based split", Default = TilingDefaults.TEX_SPLIT_PERCENT_TO_TEST)]
        public double SplitByTexturePercentToTest { get; set; }

        [Option(HelpText = "Percentage of pixels tested that should satisfy the requirement to avoid splitting a tile", Default = TilingDefaults.TEX_SPLIT_PERCENT_SATISFIED)]
        public double SplitByTexturePercentSatisfied { get; set; }

        [Option(HelpText = "Ratio of observation pixels to tile texels that would trigger a split", Default = TilingDefaults.TEX_SPLIT_MAX_PIXELS_PER_TEXEL)]
        public double SplitByTextureMaxPixelsPerTexel { get; set; }

        [Option(HelpText = "Tiling scheme (Bin, QuadX, QuadY, QuadZ, QuadAuto, Oct, Flat)", Default = TilingDefaults.TILING_SCHEME)]
        public TilingScheme TilingScheme { get; set; }

        [Option(Default = "auto", HelpText = "Texture mode (None, Clip, Bake, Backproject, auto)")]
        public string TextureMode { get; set; }

        [Option(HelpText = "Preferred observation image texture variant (Original, Blurred, Blended), falls back to Original", Default = TextureVariant.Blended)]
        public override TextureVariant TextureVariant { get; set; }

        [Option(HelpText = "Don't inpaint output to fill seams and holes when backprojecting", Default = false)]
        public bool DontInpaint { get; set; }

        [Option(HelpText = "Debug function to only mesh and texture specific tiles", Default = null)]
        public string OnlyForTiles { get; set; }

        [Option(HelpText = "Turn on debug spew while building tile tree", Default = false)]
        public bool DebugTileTree { get; set; }

        [Option(HelpText = "Turn on debug spew while building tile meshes", Default = false)]
        public bool DebugTileMeshes { get; set; }

        [Option(HelpText = "Turn on debug spew while building tile textures", Default = false)]
        public bool DebugTileTextures { get; set; }

        [Option(HelpText = "Don't use approximated areas for the tilesplit test", Default = false)]
        public bool NoApproxTileSplit { get; set; }

        [Option(HelpText = "Don't align tile bounds to camera axis for improved texture utilization when using texture projection", Default = false)]
        public bool NoAlignToCamera { get; set; }

        [Option(HelpText = "Enable synthesizing intermediate LODs when fewer precomputed LODs than tile tree levels", Default = false)]
        public bool SynthesizeExtraLODs { get; set; }

        [Option(HelpText = "Max tile tree height, negative for unlimited", Default = -1)]
        public int MaxTreeHeight { get; set; }

        [Option(HelpText = "Don't limit tile tree height to input LODs", Default = false)]
        public bool NoLimitTreeHeightToLODs { get; set; }

        [Option(HelpText = "Enforce max faces per tile even if it means increasing tree height above limit (LODs will be re-used or synthesized if enabled)", Default = false)]
        public bool EnforceMaxFacesPerTile { get; set; }

        [Option(HelpText = "Max input texture resolution, should be power of two, negative for unlimited", Default = -1)]
        public override int TextureResolution { get; set; }

        [Option(HelpText = "Max texture charts, 0 for unlimited", Default = TilingDefaults.MAX_TEXTURE_CHARTS)]
        public override int MaxTextureCharts { get; set; }

        [Option(HelpText = "Max texture stretch, 0 for none, 1 for unlimited", Default = TilingDefaults.MAX_TEXTURE_STRETCH)]
        public override double MaxTextureStretch { get; set; }

        [Option(HelpText = "Don't convert non-PDS input texture from SRGB to linear RGB", Default = false)]
        public bool NoConvertSRGBToLinearRGB { get; set; }

        [Option(HelpText = "Don't texture tiles in parallel", Default = false)]
        public bool NoTextureTilesInParallel { get; set; }
    }

    public class BuildTilingInput : TilingCommand
    {
        public const double SYNTHESIZE_LOD_RELATIVE_THRESHOLD = 0.1;

        public const int MAX_PARALLEL_TEXTURE_RES = 2048;

        private BuildTilingInputOptions options;

        private string[] onlyForTiles;

        private TextureMode textureMode = TextureMode.None;

        private double surfaceExtent = -1;
        private BoundingBox? surfaceBounds;

        private int maxTreeHeight = -1;
        private bool builtLODTileMeshes;

        private bool tacticalFrame;
        private string inputTexturePDS;

        private TextureSplitOptions textureSplitOptions;

        public class NodeLOD : NodeComponent
        {
            public int Lod; //0 = finest
        }

        public BuildTilingInput(BuildTilingInputOptions options) : base(options)
        {
            this.options = options;
        }

        public int Run()
        {
            try
            {
                if (!ParseArgumentsAndLoadCaches())
                {
                    return 0; //help
                }

                RunPhase("check for projectable texture", SetupTextureProjection);

                if (NeedSceneTexture())
                {
                    RunPhase("load input image", LoadInputTexture); //needed for CanUseTextureSplit()
                }

                bool canUseTextureSplit = withTextures && CanUseTextureSplit();
                if (withTextures && roverImages != null)
                {
                    if (canUseTextureSplit || textureMode == TextureMode.Backproject)
                    {
                        RunPhase("check or generate observation image masks", BuildObservationImageMasks);
                        RunPhase("check or generate observation frustum hulls", BuildObservationImageHulls);
                    }
                    if (textureMode == TextureMode.Backproject && options.Colorize)
                    {
                        RunPhase("check or generate observation image stats", BuildObservationImageStats);
                    }
                }

                //conserve memory: we will (probably) want the textures later, but we can reload them at that point
                RunPhase("clear LRU image cache", ClearImageCache);

                RunPhase("load input mesh", () => LoadInputMesh(requireUVs: sceneTexture != null));

                if (withTextures)
                {
                    if (canUseTextureSplit || textureMode == TextureMode.Backproject)
                    {
                        RunPhase("build occlusion datastructures", BuildSceneCaster);
                    }
                    if (canUseTextureSplit)
                    {
                        RunPhase("configure texture split criteria", ConfigureTextureSplitCriteria); //needs sceneCaster
                    }
                }

                RunPhase("build acceleration datastructures", BuildMeshOperator);

                if (withTextures && textureMode == TextureMode.Backproject)
                {
                    RunPhase("build backproject strategy", InitBackprojectStrategy); //needs mesh, meshOp, sceneCaster
                }

                RunPhase("build tile tree", BuildTileTree); //needs meshOp, sceneCaster

                RunPhase("build tile meshes", BuildTileMeshes); //needs mesh, meshOp

                RunPhase("free acceleration datastructures", () => { meshOp = null; meshOpForLOD = null; });
                RunPhase("free scene mesh", () => { mesh = null; meshLOD = null; });

                //needs sceneCaster
                RunPhase((withTextures ? "build textures and " : "") + "save tiles", BuildTileTexturesAndSaveTiles);
            }
            catch (Exception ex)
            {
                pipeline.LogException(ex);
                return 1;
            }

            StopStopwatch();

            return 0;
        }

        protected bool ParseArgumentsAndLoadCaches()
        {
            if (!base.ParseArgumentsAndLoadCaches(TILING_DIR))
            {
                return false; //help
            }

            if (!string.IsNullOrEmpty(options.OnlyForTiles))
            {
                onlyForTiles = options.OnlyForTiles.Split(',');
            }

            if (project == null && mission == null)
            {
                throw new Exception("--mission required if project not specified");
            }

            if (options.LoadLODs && string.IsNullOrEmpty(options.InputMesh))
            {
                throw new Exception("--loadlods requires --inputmesh");
            }

            if (string.IsNullOrEmpty(options.TextureMode))
            {
                options.TextureMode = "auto";
            }

            if (options.TextureMode.ToLower() == "auto")
            {
                if (!withTextures || maxTileResolution == 0)
                {
                    textureMode = TextureMode.None;
                }
                else
                {
                    textureMode = AllowCreateProject() ? TextureMode.Clip : TextureMode.Backproject;
                }
            }
            else if (!Enum.TryParse<TextureMode>(options.TextureMode, true, out textureMode))
            {
                throw new Exception(string.Format("unknown texture mode \"{0}\"", options.TextureMode));
            }

            if (maxTileResolution < 0 && textureMode != TextureMode.Clip)
            {
                throw new Exception("--maxtileresolution must be positive for texture mode " + textureMode);
            }

            pipeline.LogInfo("texture mode: {0}, max tile resolution {1}", textureMode, maxTileResolution);

            if (sceneMesh != null)
            {
                surfaceExtent = sceneMesh.SurfaceExtent;
                surfaceBounds = TilingProject.GetSurfaceBoundingBox(surfaceExtent);
            }

            if (options.MaxTreeHeight > 0)
            {
                maxTreeHeight = options.MaxTreeHeight;
            }

            //allow specifying e.g. --inputtexture=foo.png but use e.g. foo.IMG for metadata if it exists
            var pdsExts = StringHelper.ParseExts(mission.GetPDSExts(), bothCases: true);
            if (!string.IsNullOrEmpty(options.InputTexture) && pdsExts.Any(ext => options.InputTexture.EndsWith(ext)))
            {
                inputTexturePDS = options.InputTexture;
                pipeline.LogInfo("input texture is PDS: {0}", options.InputTexture);
            }
            else
            {
                foreach (var ext in pdsExts)
                {
                    var pdsFile = Path.ChangeExtension(options.InputTexture, ext);
                    if (File.Exists(pdsFile))
                    {
                        inputTexturePDS = pdsFile;
                        pipeline.LogInfo("found PDS version of input texture {0}: {1}",
                                         options.InputTexture, inputTexturePDS);
                        break;
                    }
                }
                if (inputTexturePDS == null) {
                    pipeline.LogInfo("no available PDS version of input texture {0}", options.InputTexture);
                }
            }

            return true;
        }

        private bool NeedSceneTexture()
        {
            return textureMode == TextureMode.Clip || textureMode == TextureMode.Bake;
        }

        protected override bool CanAtlasSceneMesh()
        {
            if (NeedSceneTexture() && (!TextureProjectionEnabled() || tcopts.AtlasMode != AtlasMode.Project))
            {
                //we cannot arbitrarily assign UVs to the scene mesh if we intend to clip or bake textures from it
                //(we *can* arbitrarily assign UVs to it, e.g. with UVAtlas, HeightmapAtlas, or NaieveAtlas, if we
                //intend to backproject textures from it)
                return false;
            }
            return base.CanAtlasSceneMesh();
        }

        private bool AllowCreateProject()
        {
            //this is called by hooks from base base.ParseArgumentsAndLoadCaches()
            //so don't use anything that wouldn't be availale yet in that context

            if (string.IsNullOrEmpty(options.InputMesh))
            {
                return false;
            }

            if (options.NoTextures || options.MaxTileResolution == 0)
            {
                return true;
            }

            if (options.TextureMode.ToLower() == "none")
            {
                return true;
            }

            if (options.TextureMode.ToLower() == "backproject")
            {
                return false;
            }

            if (string.IsNullOrEmpty(options.InputTexture))
            {
                return false;
            }

            return true;
        }

        protected override bool AllowUnlimitedTileResolution()
        {
            return true;
        }

        protected override bool RequireSceneMesh()
        {
            return !AllowCreateProject();
        }

        protected override Project GetProject()
        {
            if (AllowCreateProject())
            {
                string projectName = options.ProjectName;
                if (string.IsNullOrEmpty(projectName))
                {
                    projectName = StringHelper.GetLastUrlPathSegment(options.InputMesh, stripExtension: true);
                    pipeline.LogInfo("inferred project name \"{0}\"", projectName);
                }
                var project = Project.Find(pipeline, projectName);
                if (project != null)
                {
                    return project;
                }
                if (string.IsNullOrEmpty(options.Mission) || options.Mission.ToLower() == "none")
                {
                    throw new Exception("cannot create project: mission must be specified");
                }
                string productUrl = pipeline.GetStorageUrl(InitializeAlignmentProject.DATA_PRODUCT_DIR, projectName);
                string inputUrl = null;
                var init = new InitializeAlignmentProject(pipeline);
                var meshFrame = GetMeshFrame();
                if (meshFrame.ToLower() == "auto")
                {
                    meshFrame = GetAutoMeshFrame();
                }
                if (meshFrame.ToLower() == "tactical")
                {
                    meshFrame = "passthrough";
                }
                return init.Initialize(projectName, options.Mission, meshFrame, productUrl, inputUrl);
            }
            else
            {
                if (string.IsNullOrEmpty(options.ProjectName))
                {
                    throw new Exception("--projectname must be specified");
                }
                return base.GetProject();
            }
        }

        protected override MissionSpecific GetMission()
        {
            return project != null ? MissionSpecific.GetInstance(project.Mission) :
                MissionSpecific.GetInstance(options.Mission);
        }

        protected override string GetMeshFrame()
        {
            if (string.IsNullOrEmpty(options.MeshFrame))
            {
                return base.GetMeshFrame();
            }
            else 
            {
                var mf = options.MeshFrame.ToLower();
                var allowed = new string[] { "auto", "tactical", "passthrough" };
                if (Array.FindIndex(allowed, f => f == mf) < 0)
                {
                    throw new ArgumentException($"invalid mesh frame \"{options.MeshFrame}\", must be one of " +
                                                string.Join(",", allowed));
                }
                return mf;
            }
        }

        protected override string GetAutoMeshFrame()
        {
            return AllowCreateProject() ? "passthrough" : project != null ? project.MeshFrame : "newest";
        }

        protected override bool PassthroughMeshFrameAllowed()
        {
            return AllowCreateProject();
        }

        protected override bool NonPassthroughMeshFrameAllowed()
        {
            return !AllowCreateProject();
        }

        protected override void HandleSpecialMeshFrames()
        {
            meshFrame = GetMeshFrame();

            if (string.IsNullOrEmpty(meshFrame))
            {
                return;
            }

            meshFrame = meshFrame.ToLower().Trim();

            if (meshFrame == "auto")
            {
                meshFrame = GetAutoMeshFrame();
            }

            if (meshFrame == "tactical")
            {
                tacticalFrame = true;
                meshFrame = "passthrough";
            }
            else
            {
                base.HandleSpecialMeshFrames();
            }
        }

        protected override void LoadFrameCache()
        {
            if (!AllowCreateProject())
            {
                base.LoadFrameCache();
            }
        }

        protected override void LoadObservationCache()
        {
            if (!AllowCreateProject())
            {
                base.LoadObservationCache();
            }
        }

        private RoverProductId ParseProductId(string url)
        {
            var idStr = StringHelper.GetLastUrlPathSegment(url, stripExtension: true);

            string pat = @"(.+)_LOD(\d+)(?:_(\d+))?$";
            var match = Regex.Match(idStr, pat);
            if (match.Success)
            {
                idStr = match.Groups[1].Value;
            }

            var id = RoverProductId.Parse(idStr, mission, throwOnFail: false);
            if (id == null || !id.IsSingleFrame() || !id.IsSingleCamera())
            {
                return null;
            }
            return id;
        }

        private void SetupTextureProjection()
        {
            meshToCamera = null; //texture projection disabled

            if (options.NoTextureProjection)
            {
                pipeline.LogInfo("texture projection disabled");
                return;
            }

            if (string.IsNullOrEmpty(options.InputMesh) || string.IsNullOrEmpty(options.InputTexture))
            {
                pipeline.LogInfo("cannot project texture, both --inputmesh and --inputtexture are required");
                return;
            }

            var texId = ParseProductId(options.InputTexture);
            if (texId == null)
            {
                pipeline.LogInfo("cannot project texture, --inputtexture not recognized as a single frame RDR");
                return;
            }

            var meshId = ParseProductId(options.InputMesh);
            if (meshId == null)
            {
                pipeline.LogInfo("cannot project texture, --inputmesh not recognized as a single frame RDR");
                return;
            }

            if (texId.GetPartialId(mission, includeVariants: false, includeProductType: false, includeMeshType: false)
                !=
                meshId.GetPartialId(mission, includeVariants: false, includeProductType: false, includeMeshType: false))
            {
                pipeline.LogInfo("cannot project texture, --inputmesh ID does not match --inputtexture ID");
                return;
            }

            string meshFrame = tacticalFrame ? mission.GetTacticalMeshFrame(meshId) : this.meshFrame;
            meshFrame = meshFrame.ToLower();

            var allowed = new string[] { "local_level", "sitedrive", "site", "rover", "observation" };
            if (!allowed.Contains(meshFrame))
            {
                pipeline.LogInfo("cannot project texture, unhandled mesh frame {0}", meshFrame);
                return;
            }
            
            if (string.IsNullOrEmpty(inputTexturePDS))
            {
                pipeline.LogInfo("cannot project texture, --inputtexture not PDS and has no PDS sibling");
                return;
            }

            bool usingAltPDS = inputTexturePDS != options.InputTexture;
            if (usingAltPDS) 
            {
                pipeline.LogInfo("using PDS headers from {0} for input texture {1}",
                                 inputTexturePDS, options.InputTexture);
            }

            var texImg = pipeline.LoadImage(inputTexturePDS, noCache: !NeedSceneTexture() || usingAltPDS);
            if (!(texImg.Metadata is PDSMetadata))
            {
                pipeline.LogInfo("cannot project texture, --inputtexture does not have PDS metadata");
                return;
            }

            var texParser = new PDSParser((PDSMetadata)(texImg.Metadata));
            if (texParser.CameraModelRefFrame != PDSParser.ReferenceCoordinateFrame.RoverNav)
            {
                pipeline.LogInfo("cannot project texture, --inputtexture not in rover frame");
                return;
            }

            if (new string[] { "rover", "observation" }.Contains(meshFrame))
            {
                meshToCamera = Matrix.Identity;
            }
            else
            {
                //we now know the tactical mesh frame is not "rover" or "observation"
                //actually it is typically "site"
                //we need to get a transform from that frame to rover frame
                var roverOriginRotation = texParser.RoverOriginRotation;
                var originOffset = texParser.OriginOffset;
                switch (meshFrame)
                {
                    case "local_level": case "sitedrive":
                    {
                        meshToCamera = RoverCoordinateSystem.LocalLevelToRover(roverOriginRotation);
                        break;
                    }
                    case "site":
                    {
                        meshToCamera = RoverCoordinateSystem.SiteToRover(roverOriginRotation, originOffset);
                        break;
                    }
                    default:
                    {
                        pipeline.LogInfo("cannot project texture, no transform from mesh frame {0} to rover frame",
                                         meshFrame);
                        break;
                    }
                }
            }

            if (meshToCamera.HasValue)
            {
                pipeline.LogInfo("enabled texture projection");

                var camToMesh = Matrix.Invert(meshToCamera.Value);

                if (options.WriteDebug)
                {
                    var hull = ConvexHull.FromImage(texImg, farClip: options.TextureFarClip);
                    SaveMesh(ConvexHull.Transformed(hull, camToMesh).Mesh, "textureProjectorFrustumHull");
                }

                options.AtlasMode = AtlasMode.Project;

                if (!options.NoAlignToCamera && (texImg.CameraModel is CAHV))
                {
                    Vector3 a = Vector3.Normalize((texImg.CameraModel as CAHV).A);
                    a = Vector3.TransformNormal(a, camToMesh);
                    a.Z = 0;
                    if (a.Length() > MathE.EPSILON)
                    {
                        a = Vector3.Normalize(a);
                        double angle = -Math.Atan2(a.Y, a.X);
                        pipeline.LogInfo("rotating by {0:F1}deg in XY plane to align tiling frame with camera axis",
                                         MathHelper.ToDegrees(angle));
                        Vector3 c = (texImg.CameraModel as CAHV).C;
                        c = Vector3.Transform(c, camToMesh);
                        c.Z = 0;
                        meshTransform = //row mats compose left->right
                            Matrix.CreateTranslation(-c) * Matrix.CreateRotationZ(angle) * Matrix.CreateTranslation(c);
                        meshToCamera = Matrix.Invert(meshTransform.Value) * meshToCamera.Value;
                    }
                }
            }
        }

        private void LoadInputTexture()
        {
            if (!string.IsNullOrEmpty(options.InputTexture))
            {
                //can't use TextureProjectionEnabled() until sceneTexture is loaded, so use meshToCamera.HasValue here
                string texPath = (!string.IsNullOrEmpty(inputTexturePDS) && meshToCamera.HasValue) ?
                    inputTexturePDS : options.InputTexture;
                pipeline.LogInfo("loading input texture from {0}", texPath);
                sceneTexture = pipeline.LoadImage(texPath, noCache: true);
                if (string.IsNullOrEmpty(inputTexturePDS) && !options.NoConvertSRGBToLinearRGB) {
                    pipeline.LogInfo("converting non-PDS scene texture from SRGB to linear RGB");
                    sceneTexture = sceneTexture.SRGBToLinearRGB();
                }
            }
            else if (project != null && sceneMesh != null)
            {
                Guid texGuid = Guid.Empty;
                switch (options.TextureVariant)
                {
                    case TextureVariant.Original: texGuid = sceneMesh.TextureGuid; break;
                    case TextureVariant.Blurred: texGuid = sceneMesh.BlurredTextureGuid; break;
                    case TextureVariant.Blended: texGuid = sceneMesh.BlendedTextureGuid; break;
                    default: throw new Exception("unhandled texture variant: " + options.TextureVariant);
                }
                if (texGuid != Guid.Empty)
                {
                    pipeline.LogInfo("loading {0} scene texture from database", options.TextureVariant);
                    sceneTexture = pipeline.GetDataProduct<PngDataProduct>(project, texGuid, noCache: true).Image;
                }
                else
                {
                    throw new Exception($"{options.TextureVariant} scene texture in database");
                }
            }
            else
            {
                throw new Exception("cannot load input texture, no scene mesh in database");
            }
            pipeline.LogInfo("loaded {0}x{1} scene texture", sceneTexture.Width, sceneTexture.Height);
            if (!TextureProjectionEnabled() && sceneTextureResolution > 0 &&
                (sceneTexture.Width > sceneTextureResolution || sceneTexture.Height > sceneTextureResolution))
            {
                sceneTexture = sceneTexture.ResizeMax(sceneTextureResolution);
                pipeline.LogInfo("resized scene texture to {0}x{1}, max size {2}",
                                 sceneTexture.Width, sceneTexture.Height, sceneTextureResolution);
            }
            if (options.PowerOfTwoTextures && (textureMode == TextureMode.Clip) &&
                (!NumberHelper.IsPowerOfTwo(sceneTexture.Width) || !NumberHelper.IsPowerOfTwo(sceneTexture.Height)))
            {
                //the problem with this is that ResizePowerOfTwo() does not maintain aspect ratio
                //if (!TextureProjectionEnabled())
                //{
                //    int origWidth = sceneTexture.Width, origHeight = sceneTexture.Height;
                //    sceneTexture = sceneTexture.ResizePowerOfTwo();
                //    pipeline.LogInfo("resized scene texture from {0}x{1} to {2}x{3} for power of two textures",
                //                     origWidth, origHeight, sceneTexture.Width, sceneTexture.Height);
                //}
                //else
                //{
                    pipeline.LogWarn("scene texture resolution {0}x{1} is not power of two, " +
                                     "clipped tile textures may not be power of two",
                                     sceneTexture.Width, sceneTexture.Height);
                //}
            }
        }

        private bool CanUseTextureSplit()
        {
            if (options.TilingScheme == TilingScheme.Flat)
            {
                pipeline.LogInfo("texture split disabled, flat tiling scheme");
                return false;
            }

            if (maxTileResolution < 0)
            {
                pipeline.LogInfo("texture split disabled, unlimited tile resolution");
                return false;
            }

            if (options.SplitByTexturePercentToTest <= 0)
            {
                pipeline.LogInfo("texture split disabled, percent to test = 0");
                return false;
            }

            if (!(textureMode == TextureMode.Backproject || TextureProjectionEnabled()))
            {
                pipeline.LogInfo("texture split disabled, texture mode is not backproject and no PDS scene camera");
                return false;
            }

            return true;
        }

        private void ConfigureTextureSplitCriteria()
        {
            if (sceneCaster == null)
            {
                pipeline.LogInfo("texture split disabled, no scene caster");
                return;
            }

            CameraInstance[] cams = null;
            if (imageObservations != null && frameCache != null && obsToHull != null)
            {
                CameraInstance obsToCam(Observation obs)
                {
                    var xform = frameCache.GetObservationTransform(obs, meshFrame, options.UsePriors);
                    if (xform == null)
                    {
                        return null;
                    }
                    CameraInstance cam = new CameraInstance();
                    cam.CameraToMesh = xform.Mean;
                    cam.MeshToCamera = Matrix.Invert(xform.Mean);
                    cam.CameraModel = obs.CameraModel;
                    cam.HullInMesh = obsToHull[obs.Name];
                    cam.WidthPixels = obs.Width;
                    cam.HeightPixels = obs.Height;
                    return cam;
                }
                cams = roverImages.Select(obsToCam).ToArray();
            }
            else if (TextureProjectionEnabled())
            {
                var hullInCam =
                    ConvexHull.FromParams(sceneTexture.CameraModel, sceneTexture.Width, sceneTexture.Height);
                var cam = new CameraInstance();
                cam.CameraToMesh = Matrix.Invert(meshToCamera.Value);
                cam.MeshToCamera = meshToCamera.Value;
                cam.CameraModel = sceneTexture.CameraModel;
                cam.HullInMesh = ConvexHull.Transformed(hullInCam, cam.CameraToMesh);
                cam.WidthPixels = sceneTexture.Width;
                cam.HeightPixels = sceneTexture.Height;
                cams = new CameraInstance[] { cam };
            }

            if (cams == null || cams.Length == 0)
            {
                pipeline.LogInfo("texture split disabled, no available cameras");
                return;
            }

            pipeline.LogInfo("texture split enabled");

            textureSplitOptions = new TextureSplitOptions()
            {
                RespectMaxTexelsPerMeter = !options.NoTextureSplitRespectMaxTexelsPerMeter,
                PercentPixelsToTest = options.SplitByTexturePercentToTest,
                PercentPixelsSatisfied = options.SplitByTexturePercentSatisfied,
                MaxPixelsPerTexel = options.SplitByTextureMaxPixelsPerTexel,
                MaxTileResolution = maxTileResolution, //> 0 otherwise texture split would be disabled
                MinTileResolution = minTileResolution,
                MaxTexelsPerMeter = options.MaxTexelsPerMeter,
                MaxOrbitalTexelsPerMeter = options.MaxOrbitalTexelsPerMeter,
                MaxTextureStretch = maxTextureStretch,
                PowerOfTwoTextures = options.PowerOfTwoTextures,
                TextureMode = textureMode,
                CameraInstances = cams,
                SceneCaster = sceneCaster,
                SurfaceBounds = surfaceBounds,
                RaycastTolerance = options.RaycastTolerance,
                RedoUVs = !options.NoRedoTileMeshUVs,
                AtlasTile = (mesh, bounds, res) => AtlasTile(mesh, bounds, res),
                Warn = msg => pipeline.LogWarn(msg)
            };
        }

        private void BuildTileTree()
        {
            bool wasVerbose = pipeline.Verbose;
            bool wasDebug = pipeline.Debug;
            if (options.DebugTileTree)
            {
                pipeline.Verbose = pipeline.Debug = true;
            }

            double minTileExtent = options.MinTileExtent;
            var meshBounds = BoundingBoxExtensions.Union(meshOpForLOD.Select(o => o.Bounds).ToArray());
            if (!meshBounds.IsEmpty() && options.MinTileExtentRel > 0)
            {
                Vector2 meshSize = meshBounds.GetFaceSizePerpendicularToAxis(meshBounds.MinAxis());
                minTileExtent = Math.Min(minTileExtent, options.MinTileExtentRel * Math.Min(meshSize.X, meshSize.Y));
                if (minTileExtent < options.MinTileExtent)
                {
                    pipeline.LogInfo("replacing min tile extent {0:f3} with {1:f3} for {2} mesh, min rel extent {3:f3}",
                                     options.MinTileExtent, minTileExtent, meshBounds.FmtExtent(),
                                     options.MinTileExtentRel);
                }
            }

            if (options.TilingScheme == TilingScheme.Flat)
            {
                BuildFlatTileTree(meshBounds);
            }
            else if (meshLOD.Count > 1)
            {
                if (!options.NoLimitTreeHeightToLODs)
                {
                    maxTreeHeight = meshLOD.Count;
                }
                tileTree = DefineTiles
                    .BuildTileTreeFromLODs(meshOpForLOD, options.TilingScheme, options.MaxFacesPerTile,
                                           minTileExtent, options.MaxLeafArea,
                                           textureSplitOptions, !options.NoApproxTileSplit, maxTreeHeight,
                                           options.EnforceMaxFacesPerTile,
                                           msg => pipeline.LogInfo(msg), msg => pipeline.LogVerbose(msg));
            }
            else
            {
                tileTree = DefineTiles
                    .BuildTileTreeFromInputs(new List<MeshImagePair>() { new MeshImagePair(meshOp: meshOp) },
                                             options.TilingScheme, options.MaxFacesPerTile, minTileExtent,
                                             options.MaxLeafArea, options.MaxOrbitalLeafArea, surfaceExtent,
                                             textureSplitOptions, !options.NoApproxTileSplit, maxTreeHeight,
                                             options.EnforceMaxFacesPerTile,
                                             msg => pipeline.LogInfo(msg), msg => pipeline.LogVerbose(msg));
            }

            tileTree.DumpStats(msg => pipeline.LogInfo(msg));

            pipeline.Verbose = wasVerbose;
            pipeline.Debug = wasDebug;
        }

        private void BuildFlatTileTree(BoundingBox bounds)
        {
            float sx = (float)(bounds.Max.X - bounds.Min.X);
            float sy = (float)(bounds.Max.Y - bounds.Min.Y);
            int nx = (int)Math.Ceiling(sx / options.MinTileExtent);
            int ny = (int)Math.Ceiling(sy / options.MinTileExtent);
            float tx = sx / nx;
            float ty = sy / ny;
            pipeline.LogInfo("building {0}x{1} flat tile tree for {2:f3}x{3:f3}m scene, tile size {4:f3}x{5:f3}m",
                             nx, ny, sx, sy, tx, ty);

            tileTree = new SceneNode("root");
            tileTree.AddComponent<NodeBounds>().Bounds = bounds;
            float sd = (float)Math.Sqrt(sx * sx + sy * sy);
            tileTree.AddComponent<NodeGeometricError>().Error = sd; //high enough that root shouldn't get used

            //mission surface frames are X north, Y right, Z down
            int k = 0;
            for (int i = 0; i < nx; i++)
            {
                for (int j = 0; j < ny; j++)
                {
                    var min = new Vector3(bounds.Min.X + i       * tx, bounds.Min.Y + j       * ty, bounds.Min.Z);
                    var max = new Vector3(bounds.Min.X + (i + 1) * tx, bounds.Min.Y + (j + 1) * ty, bounds.Max.Z);
                    var leafBounds = new BoundingBox(min, max);
                    var leaf = new SceneNode((k++).ToString(), tileTree.Transform);
                    leaf.AddComponent(new NodeBounds(leafBounds));
                    leaf.AddComponent<NodeGeometricError>().Error = 0;
                }
            }
        }

        private void BuildTileMeshes()
        {
            bool wasVerbose = pipeline.Verbose;
            bool wasDebug = pipeline.Debug;
            if (options.DebugTileMeshes)
            {
                pipeline.Verbose = pipeline.Debug = true;
            }
            if (meshLOD.Count > 1)
            {
                BuildLODTileMeshes();
            }
            else
            {
                BuildLeafMeshes();
            }
            pipeline.Verbose = wasVerbose;
            pipeline.Debug = wasDebug;
        }

        private void BuildLODTileMeshes()
        {
            builtLODTileMeshes = true;

            //it is possible that a tiling scheme may choose not to split a node
            //which means there can be leaf nodes at any depth in the tree
            //the approach to map tiling nodes to pre-existing LODs is as follows
            //leaf nodes always clip from the highest LOD mesh
            //parent nodes clip from the next-coarser LOD mesh than the coarsest mesh used by any of their children
            var nodes = new List<SceneNode>();
            int assignLODsAndCollectNodes(SceneNode node)
            {
                int lod = 0;
                if (!node.IsLeaf)
                {
                    foreach (var child in node.Children)
                    {
                        lod = Math.Max(assignLODsAndCollectNodes(child), lod);
                    }
                    lod++;
                }
                node.AddComponent<NodeLOD>().Lod = lod;
                nodes.Add(node); //add parent after children - meshes will be created leaves first and root last
                return lod;
            }

            int rootLOD = assignLODsAndCollectNodes(tileTree);

            if (rootLOD >= meshLOD.Count && (!NeedSceneTexture() || CanAtlasSceneMesh()) && options.SynthesizeExtraLODs)
            {
                SynthesizeExtraLODs(rootLOD + 1);
            }

            int nearestAvailableLOD(int lod)
            {
                int maxAvailableLOD = meshLOD.Count - 1;
                if (rootLOD > maxAvailableLOD)
                {
                    lod = (int)Math.Ceiling(((double)lod / rootLOD) * maxAvailableLOD);
                }
                return Math.Max(Math.Min(lod, maxAvailableLOD), 0);
            }

            if (options.WriteDebug)
            {
                pipeline.LogInfo("saving {0} debug LOD meshes", meshLOD.Count);
                for (int lod = 0; lod < meshLOD.Count; lod++)
                {
                    pipeline.LogInfo("LOD {0}: {1} vertices, {2} faces",
                                     lod, Fmt.KMG(meshLOD[lod].Vertices.Count), Fmt.KMG(meshLOD[lod].Faces.Count));
                }
                string texFile = null;
                if (sceneTexture != null)
                {
                    texFile = "sceneTexture" + imageExt;
                    SaveImage(sceneTexture, texFile);
                }
                for (int i = 0; i < meshLOD.Count; i++)
                {
                    SaveMesh(meshLOD[i], "sceneLOD" + i, texFile);
                }
            }

            pipeline.LogInfo("using {0}/{1} LODs", rootLOD + 1, meshLOD.Count);

            int nf = 0, cn = 0, nn = nodes.Count, np = 0;
            double lastSpew = UTCTime.Now();
            CoreLimitedParallel.ForEach(nodes, node =>
            {
                Interlocked.Increment(ref cn);

                if (onlyForTiles != null && !onlyForTiles.Contains(node.Name))
                {
                    return;
                }

                Interlocked.Increment(ref np);

                int lod = nearestAvailableLOD(node.GetComponent<NodeLOD>().Lod);
                
                double now = UTCTime.Now();
                if (!options.NoProgress && (pipeline.Verbose || ((now - lastSpew) > SPEW_INTERVAL_SEC)))
                {
                    pipeline.LogInfo("building tile mesh {0}/{1} ({2:F2}%){3}: tile {4}, clipping from LOD {5}",
                                     cn, nn, 100 * cn / (float)nn,
                                     np > 1 ? ", processing " + np + " in parallel" : "", node.Name, lod);
                    lastSpew = now;
                }

                Mesh tileMesh = MakeTileMesh(node, meshOpForLOD[lod]);

                if (tileMesh != null && tileMesh.Faces.Count > 0 && (!withTextures || tileMesh.HasUVs))
                {
                    SaveTileMesh(node.Name, tileMesh);
                }
                else if (node.IsRoot && node.IsLeaf)
                {
                    pipeline.LogWarn("adding empty mesh to root node of empty tileset");
                    SaveTileMesh(node.Name, new Mesh(hasNormals: true, hasUVs: withTextures));
                }
                else
                {
                    Interlocked.Increment(ref nf);
                }

                Interlocked.Decrement(ref np);
            });

            if (nf > 0)
            {
                pipeline.LogWarn("failed to generate meshes for {0} tiles", nf);
            }
        }

        private void SynthesizeExtraLODs(int newNumLODs)
        {
            bool genUVs = NeedSceneTexture() && CanAtlasSceneMesh();
            while (newNumLODs > meshLOD.Count)
            {
                int maxDiff = 0;
                int srcLOD = 0;
                for (int i = 0; i < meshLOD.Count - 1; i++)
                {
                    int diff = meshLOD[i].Faces.Count - meshLOD[i + 1].Faces.Count;
                    if (diff > maxDiff)
                    {
                        maxDiff = diff;
                        srcLOD = i;
                    }
                }

                Mesh srcMesh = meshLOD[srcLOD];
                Mesh newMesh = srcMesh;
                if (maxDiff > SYNTHESIZE_LOD_RELATIVE_THRESHOLD * srcMesh.Faces.Count)
                {
                    int target = srcMesh.Faces.Count - (int)(0.5 * maxDiff);
                    pipeline.LogInfo("synthesizing new LOD by decimating LOD {0} ({1} tris) to {2} tris with {3}",
                                     srcLOD, Fmt.KMG(srcMesh.Faces.Count), Fmt.KMG(target), options.MeshDecimator);
                    newMesh = srcMesh.Decimated(target, options.MeshDecimator, logger: pipeline); //preserves normals
                    if (newMesh.Faces.Count < (srcMesh.Faces.Count - maxDiff) ||
                        newMesh.Faces.Count > srcMesh.Faces.Count)
                    {
                        pipeline.LogWarn("not using synthesized mesh, face count {0} out of range {1}-{2}",
                                         Fmt.KMG(newMesh.Faces.Count), Fmt.KMG(srcMesh.Faces.Count - maxDiff),
                                         Fmt.KMG(srcMesh.Faces.Count));
                        newMesh = srcMesh;
                    }
                    else if (genUVs)
                    {
                        try
                        {
                            AtlasMesh(newMesh, sceneTextureResolution, "new LOD");
                            if (newMesh.Faces.Count == 0 || newMesh.Vertices.Count == 0)
                            {
                                throw new Exception("empty mesh after atlassing");
                            }
                        }
                        catch (Exception ex)
                        {
                            pipeline.LogException(ex, "error atlassing synthesized mesh, not using");
                            newMesh = srcMesh;
                        }
                    }
                }
                else
                {
                    pipeline.LogInfo("duplicating existing LOD {0}, difference {1} to next LOD < {2} * {3}",
                                     srcLOD, Fmt.KMG(maxDiff), SYNTHESIZE_LOD_RELATIVE_THRESHOLD,
                                     Fmt.KMG(srcMesh.Faces.Count));
                }

                //insert newMesh at appropriate spot
                //understanding that its actual face count might not be target
                //LODs are kept in descending order from finest to coarsest
                int newIdx = 0;
                while (newIdx < meshLOD.Count && newMesh.Faces.Count <= meshLOD[newIdx].Faces.Count)
                {
                    newIdx++;
                }

                pipeline.LogInfo("inserting {0} LOD with {1} tris " +
                                 "between LODs {2} ({3} tris) and {4} ({5} tris)",
                                 newMesh != srcMesh ? "new" : "duplicate",
                                 Fmt.KMG(newMesh.Faces.Count), newIdx - 1,
                                 Fmt.KMG(newIdx - 1 >= 0 ? meshLOD[newIdx - 1].Faces.Count : 0), newIdx,
                                 Fmt.KMG(newIdx < meshLOD.Count ? meshLOD[newIdx].Faces.Count : 0));
                
                meshLOD.Insert(newIdx, newMesh); //inserts new item *before* existing item at specified index
            }

            mesh = meshLOD.First();

            pipeline.LogInfo("{0} LODs after synthesis:", meshLOD.Count);
            for (int lod = 0; lod < meshLOD.Count; lod++)
            {
                pipeline.LogInfo("LOD {0}: {1} vertices, {2} faces",
                                 lod, Fmt.KMG(meshLOD[lod].Vertices.Count), Fmt.KMG(meshLOD[lod].Faces.Count));
            }

            BuildMeshOperator();
        }

        private void BuildLeafMeshes()
        {
            int cn = 0, nf = 0, nn = tileTree.Leaves().Count(), np = 0;
            double lastSpew = UTCTime.Now();
            CoreLimitedParallel.ForEach(tileTree.Leaves(), leaf =>
            {
                Interlocked.Increment(ref cn);

                if (onlyForTiles != null && !onlyForTiles.Contains(leaf.Name))
                {
                    return;
                }

                Interlocked.Increment(ref np);

                double now = UTCTime.Now();
                if (!options.NoProgress && (pipeline.Verbose || (now - lastSpew) > SPEW_INTERVAL_SEC))
                {
                    pipeline.LogInfo("building leaf mesh {0}/{1} ({2:F2}%){3}: {4}",
                                     cn, nn, 100 * cn / (float)nn,
                                     np > 1 ? ", processing " + np + " in parallel" : "", leaf.Name);
                    lastSpew = now;
                }

                Mesh tileMesh = MakeTileMesh(leaf, meshOpForLOD.First());

                if (tileMesh != null && tileMesh.Faces.Count > 0 && (!withTextures || tileMesh.HasUVs))
                {
                    SaveTileMesh(leaf.Name, tileMesh);
                }
                else if (leaf.IsRoot)
                {
                    pipeline.LogWarn("adding empty mesh to root node of empty tileset");
                    SaveTileMesh(leaf.Name, new Mesh(hasNormals: true, hasUVs: withTextures));
                }
                else
                {
                    Interlocked.Increment(ref nf);
                }

                Interlocked.Decrement(ref np);
            });

            if (nf > 0)
            {
                pipeline.LogWarn("failed to generate meshes for {0} leaves", nf);
            }

            DumpAtlasStats();
        }

        private void BuildTileTexturesAndSaveTiles()
        {
            bool wasVerbose = pipeline.Verbose;
            bool wasDebug = pipeline.Debug;
            if (options.DebugTileTextures)
            {
                options.VerboseBackproject = true;
                pipeline.Verbose = pipeline.Debug = true;
            }

            tileList = new TileList()
            {
                MeshExt = meshExt,
                ImageExt = withTextures ? imageExt : null,
                HasIndexImages = !options.NoIndexImages,
                TilingScheme = options.TilingScheme,
                TextureMode = textureMode,
                LeafNames = new List<string>(),
                ParentNames = new List<string>(),
            };

            if (options.TilingScheme == TilingScheme.Flat)
            {
                tileList.ParentNames.Add(tileTree.Name); //root is only parent in flat tiling
            }

            tileList.RootTransform = meshTransform.HasValue ? Matrix.Invert(meshTransform.Value) : Matrix.Identity;

            var tilesToTexture = tileTree.DepthFirstTraverse()
                .Where(t => TileMeshExists(t.Name))
                .OrderByDescending(t => t.Name)
                .ToList();
            int nn = tilesToTexture.Count;

            string texMsg = textureMode == TextureMode.Bake ? "baking" :
                textureMode == TextureMode.Backproject ? "backprojecting" :
                textureMode == TextureMode.Clip ? "clipping" :
                "no";

            pipeline.LogInfo("processing {0} tiles, {1} max {2}x{2} {3} textures{4}",
                             nn, texMsg, maxTileResolution, options.TextureVariant,
                             options.TextureVariant != TextureVariant.Original ?
                             " (falling back to " + TextureVariant.Original + ")" : "");

            if (textureMode == TextureMode.Backproject)
            {
                pipeline.LogInfo("backproject quality {0}, prefer color {1}, texture far clip {2:f3}",
                                 options.BackprojectQuality, options.PreferColor, options.TextureFarClip);
                if (!options.NoIndexImages)
                {
                    pipeline.LogInfo("saving tile backproject index images");
                }
                pipeline.LogInfo("colorize: {0}", options.Colorize);
            }

            if (textureMode == TextureMode.Clip && !builtLODTileMeshes && !TextureProjectionEnabled())
            {
                pipeline.LogWarn("clipping leaf tile textures but baking parent tile textures");
            }

            Image sceneIndex = null;
            if (!options.NoIndexImages)
            {
                pipeline.LogInfo("saving tile backproject index images");

                if (sceneTexture != null && (textureMode == TextureMode.Bake || textureMode == TextureMode.Clip))
                {
                    sceneIndex = new Image(3, sceneTexture.Width, sceneTexture.Height);
                    for (int r = 0; r < sceneIndex.Height; r++)
                    {
                        for (int c = 0; c < sceneIndex.Width; c++)
                        {
                            sceneIndex[0, r, c] = Observation.MIN_INDEX;
                            sceneIndex[1, r, c] = r;
                            sceneIndex[2, r, c] = c;
                        }
                    }
                }
            }

            MultiMeshClipper bakeClipper = null;
            if (textureMode == TextureMode.Bake)
            {
                bakeClipper = new MultiMeshClipper(powerOfTwoTextures: options.PowerOfTwoTextures, logger: pipeline);
                bakeClipper.AddInput(new MeshImagePair(mesh, sceneTexture, sceneIndex));
                bakeClipper.InitTextureBaker();
            }

            double lastSpew = UTCTime.Now();
            int np = 0, cn = 0, nf = 0, ns = 0;
            void textureAndSaveTile(SceneNode tile)
            {
                Interlocked.Increment(ref cn);

                if (onlyForTiles != null && !onlyForTiles.Contains(tile.Name))
                {
                    return;
                }

                Interlocked.Increment(ref np);

                double now = UTCTime.Now();
                if (!options.NoProgress && (pipeline.Verbose || ((now - lastSpew) > SPEW_INTERVAL_SEC)))
                {
                    pipeline.LogInfo("{0}saving tile {1}/{2} ({3:F2}%){4}: {5}",
                                     withTextures ? "texturing and " : "", 
                                     cn, nn, 100 * cn / (float)nn,
                                     np > 1 ? ", processing " + np + " in parallel" : "", tile.Name);
                    lastSpew = now;
                }

                CheckGarbage();

                var mip = new MeshImagePair();
                mip.Mesh = LoadTileMesh(tile.Name);

                int resolution = GetTileResolution(mip.Mesh, tile.GetComponent<NodeBounds>().Bounds, tile.Name);

                if (!mip.Mesh.HasFaces)
                {
                    if (textureMode != TextureMode.None)
                    {
                        pipeline.LogWarn("creating blank texture for empty tile " + tile.Name);
                        int minTileResolution = TilingDefaults.MIN_TILE_RESOLUTION;
                        mip.Image = new Image(3, minTileResolution, minTileResolution);
                        if (!options.NoIndexImages)
                        {
                            mip.Index = new Image(3, minTileResolution, minTileResolution);
                        }
                    }
                }
                else if (textureMode == TextureMode.Bake)
                {
                    pipeline.LogVerbose("baking texture for tile " + tile.Name);
                    var tmp = bakeClipper.BakeTexture(mip.Mesh, resolution, maxTextureStretch,
                                                      msg => pipeline.LogVerbose(msg));
                    if (tmp != null)
                    {
                        mip.Mesh = tmp.Mesh; //may have been atlassed
                        mip.Image = tmp.Image;
                        mip.Index = tmp.Index;
                    }
                }
                else if (textureMode == TextureMode.Backproject)
                {                
                    pipeline.LogVerbose("backprojecting texture for tile " + tile.Name);
                    BackprojectTile(mip, tile.Name, sceneCaster, sceneCaster, null, resolution);
                }
                else if (textureMode == TextureMode.Clip)
                {
                    pipeline.LogVerbose("clipping texture for tile " + tile.Name);
                    var texClipper = new TexturedMeshClipper(powerOfTwoTextures: options.PowerOfTwoTextures,
                                                             logger: pipeline, logPrefix: tile.Name);
                    var tmp = texClipper.RemapMeshClipImage(mip.Mesh, sceneTexture, sceneIndex,
                                                            tile.IsLeaf ? maxTileResolution : resolution);
                    mip.Mesh = tmp.Mesh; //may have been re-atlassed
                    mip.Image = tmp.Image;
                    mip.Index = tmp.Index;
                }

                if (mip.Mesh != null && mip.Mesh.HasFaces && mip.Image != null)
                {
                    if (options.WriteDebug)
                    {
                        SaveImage(mip.Image, tile.Name + "_rawTexture");
                        SaveMesh(mip.Mesh, tile.Name + "_rawTexture", tile.Name + "_rawTexture");
                        if (mip.Index != null)
                        {
                            SaveImage(Backproject.GenerateIndexPreviewImage(mip.Index), tile.Name + "_indexPreview");
                        }
                    }

                    if (maxTextureStretch < 1 && !options.PowerOfTwoTextures)
                    {
                        pipeline.LogVerbose("clipping image and remapping UVs for tile " + tile.Name);
                        mip.Image = mip.Mesh.ClipImageAndRemapUVs(mip.Image, ref mip.Index);

                        if (options.WriteDebug)
                        {
                            SaveImage(mip.Image, tile.Name + "_clippedTexture");
                            SaveMesh(mip.Mesh, tile.Name + "_clippedTexture", tile.Name + "_clippedTexture");
                        }
                    }
                }

                if (mip.Mesh != null && (!withTextures || mip.Image != null))
                {
                    //need to re-save the mesh here just to add the image name (e.g. PLY embeds the image name)
                    SaveTileContent(tile.Name, mip, tile.IsLeaf);
                    Interlocked.Increment(ref ns);
                }
                else
                {
                    Interlocked.Increment(ref nf);
                }

                //conserve memory
                //tile.AddComponent(mip);
                tile.AddComponent(new MeshImagePairStats(mip));

                Interlocked.Decrement(ref np);
            }

            bool textureTilesInParallel = !options.NoTextureTilesInParallel;
            if (minTileResolution > MAX_PARALLEL_TEXTURE_RES)
            {
                textureTilesInParallel = false;
            }

            if (textureTilesInParallel)
            {
                CoreLimitedParallel.ForEachNoPartition(tilesToTexture, textureAndSaveTile);
            }
            else
            {
                pipeline.LogInfo("texturing tiles serially");
                Serial.ForEach(tilesToTexture, textureAndSaveTile);
            }

            if (withTextures && nf > 0)
            {
                pipeline.LogWarn("failed to generate textures for {0} tiles", nf);
            }

            pipeline.LogInfo("{0} tiles built successfully", ns);

            if (textureMode == TextureMode.Backproject)
            {
                pipeline.LogInfo("backprojected {0} pixels from surface observations, {1} from orbital, {2} failed, " +
                                 "tried up to {3} observations per pixel",
                                 Fmt.KMG(numBackprojectedSurfacePixels), Fmt.KMG(numBackprojectedOrbitalPixels),
                                 Fmt.KMG(numBackprojectFailedPixels), numBackprojectFallbacks + 1);
            }

            tileTree.DumpStats(msg => pipeline.LogInfo(msg));

            if (!options.NoSave)
            {
                if (sceneMesh == null)
                {
                    pipeline.LogInfo("creating scene mesh");
                    sceneMesh = SceneMesh.Create(pipeline, project);
                }

                pipeline.LogInfo("saving tile list");
                pipeline.SaveDataProduct(project, tileList, noCache: true);
                sceneMesh.TileListGuid = tileList.Guid;

                if (TextureProjectionEnabled())
                {
                    pipeline.LogInfo("saving texture projector");
                    var textureProjector = new TextureProjector(sceneTexture, meshToCamera.Value);
                    if (textureMode == TextureMode.Clip && !builtLODTileMeshes)
                    {
                        pipeline.LogInfo("saving input image for clipping parent textures");
                        var textureProd = new PngDataProduct(sceneTexture);
                        pipeline.SaveDataProduct(project, textureProd, noCache: true);
                        textureProjector.TextureGuid = textureProd.Guid;
                    }
                    pipeline.SaveDataProduct(project, textureProjector, noCache: true);
                    sceneMesh.TextureProjectorGuid = textureProjector.Guid;
                }
                else
                {
                    sceneMesh.TextureProjectorGuid = Guid.Empty;
                }

                sceneMesh.Save(pipeline);
            }

            pipeline.Verbose = wasVerbose;
            pipeline.Debug = wasDebug;
        }

        private int GetTileResolution(Mesh tileMesh, BoundingBox tileBounds, string tileName = null)
        {
            if (minTileResolution == maxTileResolution)
            {
                return maxTileResolution;
            }

            double texelsPerMeter =
                TilingProject.GetMaxTexelsPerMeter(tileBounds, surfaceBounds, options.MaxTexelsPerMeter,
                                                   options.MaxOrbitalTexelsPerMeter);
            return SceneNodeTilingExtensions.
                GetTileResolution(tileMesh, maxTileResolution, minTileResolution, texelsPerMeter,
                                  options.PowerOfTwoTextures,
                                  msg => pipeline.LogVerbose((tileName != null ? $"tile {tileName}: " : "") + msg));
        }

        private Mesh MakeTileMesh(SceneNode tile, MeshOperator meshOp)
        {
            Mesh tileMesh = null;

            if (!tile.HasComponent<NodeBounds>())
            {
                throw new Exception(string.Format("tile {0} missing bounds", tile.Name));
            }
            var tileBounds = tile.GetComponent<NodeBounds>().Bounds;

            //clip the big mesh to get a tile's mesh
            try
            {
                tileMesh = meshOp.Clipped(tileBounds);
                if (options.WriteDebug)
                {
                    SaveMesh(tileMesh, tile.Name + "_clipped");
                }
            }
            catch (Exception ex)
            {
                pipeline.LogError("error clipping mesh for tile {0}: {1}", tile.Name, ex.Message);
                return null;
            }

            if (tileMesh.Vertices.Count == 0)
            {
                pipeline.LogWarn("tile {0} empty", tile.Name);
                return tileMesh;
            }

            AtlasTile(tileMesh, tileBounds, -1, tile.Name);

            return tileMesh;
        }

        private void AtlasTile(Mesh tileMesh, BoundingBox tileBounds, int tileRes, string tileName = null)
        {
            tileRes = tileRes > 0 ? tileRes : GetTileResolution(tileMesh, tileBounds, tileName);

            bool didAtlas = false;
            if (textureMode == TextureMode.Bake || textureMode == TextureMode.Backproject)
            {
                if (!tileMesh.HasUVs || !options.NoRedoTileMeshUVs)
                {
                    if (TilingProject.IsOrbitalTile(tileBounds, surfaceBounds))
                    {
                        HeightmapAtlasMesh(tileMesh, "orbital tile" + (tileName != null ? $" {tileName}" : ""));
                        didAtlas = true;
                    }
                    else
                    {
                        AtlasMesh(tileMesh, tileRes, "tile" + (tileName != null ? $" {tileName}" : ""));
                        didAtlas = true;
                    }
                }
                else
                {
                    pipeline.LogVerbose("using existing UVs on tile " + (tileName != null ? $" {tileName}" : ""));
                }
                tileMesh.RescaleUVsForTexture(tileRes, tileRes, maxTextureStretch);
            }
            else if (textureMode == TextureMode.Clip)
            {
                if ((!tileMesh.HasUVs || !options.NoRedoTileMeshUVs) && TextureProjectionEnabled())
                {
                    pipeline.LogVerbose("(re-)atlasing tile{0} mesh with texture projection",
                                        (tileName != null ? $" {tileName}" : ""));
                    ProjectTexture(tileMesh);
                    didAtlas = true;
                }
                else if (!tileMesh.HasUVs)
                {
                    throw new Exception($"cannot clip texture for tile{tileName}: " +
                                        "scene mesh missing UVs and texture projection disabled");
                }
                else
                {
                    pipeline.LogVerbose("using existing UVs on tile" + (tileName != null ? $" {tileName}" : ""));
                }
            }
            if (didAtlas && tileName != null && options.WriteDebug)
            {
                SaveMesh(tileMesh, tileName + "_atlassed");
            }
        }
    }
}
